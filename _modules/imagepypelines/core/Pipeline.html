<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>imagepypelines.core.Pipeline &#8212; ImagePypelines 0.3.2-alpha documentation</title>
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/ip_custom.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/gallery-dataframe.css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/js/copybutton.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-sphinx.js "></script>
  
<style type="text/css">
  ul.ablog-archive {
    list-style: none;
    overflow: auto;
    margin-left: 0px;
  }
  ul.ablog-archive li {
    float: left;
    margin-right: 5px;
    font-size: 80%;
  }
  ul.postlist a {
    font-style: italic;
  }
  ul.postlist-style-disc {
    list-style-type: disc;
  }
  ul.postlist-style-none {
    list-style-type: none;
  }
  ul.postlist-style-circle {
    list-style-type: circle;
  }
</style>

  </head><body>

  <div id="navbar" class="navbar navbar-default ">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html"><span><img src="../../../_static/ip_logo.svg"></span>
          ImagePypelines</a>
        <span class="navbar-text navbar-version pull-left"><b>0.3</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../../getting_started.html">Getting Started</a></li>
                <li><a href="../../../examples/index.html">Examples</a></li>
                <li><a href="../../../blog/2020.html">Blog</a></li>
                <li><a href="../../../docs/core.html">Documentation</a></li>
                <li><a href="../../../plugins.html">Plugins</a></li>
                <li><a href="https://github.com/jmaggio14/imagepypelines">Github</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html"> <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
       <h1>Source code for imagepypelines.core.Pipeline</h1><div class="highlight"><pre>
<span></span><span class="c1"># @Email: jmaggio14@gmail.com</span>
<span class="c1"># @Website: https://www.imagepypelines.org/</span>
<span class="c1"># @License: https://github.com/jmaggio14/imagepypelines/blob/master/LICENSE</span>
<span class="c1"># @github: https://github.com/jmaggio14/imagepypelines</span>
<span class="c1">#</span>
<span class="c1"># Copyright (c) 2018 - 2020 Jeff Maggio, Jai Mehra, Ryan Hartzell</span>
<span class="kn">from</span> <span class="nn">..Logger</span> <span class="kn">import</span> <span class="n">get_logger</span><span class="p">,</span> <span class="n">MASTER_LOGGER</span>
<span class="kn">from</span> <span class="nn">.Block</span> <span class="kn">import</span> <span class="n">Block</span>
<span class="kn">from</span> <span class="nn">.Data</span> <span class="kn">import</span> <span class="n">Data</span>
<span class="kn">from</span> <span class="nn">.block_subclasses</span> <span class="kn">import</span> <span class="n">Input</span><span class="p">,</span> <span class="n">Leaf</span><span class="p">,</span> <span class="n">PipelineBlock</span>
<span class="kn">from</span> <span class="nn">.constants</span> <span class="kn">import</span> <span class="n">UUID_ORDER</span>
<span class="kn">from</span> <span class="nn">.Exceptions</span> <span class="kn">import</span> <span class="n">PipelineError</span>
<span class="kn">from</span> <span class="nn">.io_tools</span> <span class="kn">import</span> <span class="n">passgen</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="kn">import</span> <span class="n">Timer</span>
<span class="kn">from</span> <span class="nn">.DashboardComm</span> <span class="kn">import</span> <span class="n">DashboardComm</span>

<span class="kn">from</span> <span class="nn">cryptography.fernet</span> <span class="kn">import</span> <span class="n">Fernet</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">uuid</span> <span class="kn">import</span> <span class="n">uuid4</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">networkx.readwrite</span> <span class="kn">import</span> <span class="n">json_graph</span>
<span class="kn">import</span> <span class="nn">hashlib</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">dill</span>
<span class="kn">import</span> <span class="nn">json</span>

<span class="n">STATUS_NOT_STARTED</span> <span class="o">=</span> <span class="s2">&quot;not started&quot;</span>
<span class="sd">&quot;&quot;&quot;status constant for nodes that haven&#39;t yet been started&quot;&quot;&quot;</span>

<span class="n">STATUS_PROCESSING</span>  <span class="o">=</span> <span class="s2">&quot;processing&quot;</span>
<span class="sd">&quot;&quot;&quot;status constant for nodes that are currently processing&quot;&quot;&quot;</span>

<span class="n">STATUS_COMPLETE</span>    <span class="o">=</span> <span class="s2">&quot;done&quot;</span>
<span class="sd">&quot;&quot;&quot;status constant for nodes that have completed their work&quot;&quot;&quot;</span>

<span class="n">MSG_GRAPH</span>  <span class="o">=</span> <span class="s2">&quot;graph&quot;</span>
<span class="sd">&quot;&quot;&quot;message type for graph messages&quot;&quot;&quot;</span>

<span class="n">MSG_STATUS</span> <span class="o">=</span> <span class="s2">&quot;status&quot;</span>
<span class="sd">&quot;&quot;&quot;message type for status messages&quot;&quot;&quot;</span>

<span class="n">MSG_RESET</span>  <span class="o">=</span> <span class="s2">&quot;reset&quot;</span>
<span class="sd">&quot;&quot;&quot;message type for reset messages&quot;&quot;&quot;</span>

<span class="n">MSG_ERROR</span>  <span class="o">=</span> <span class="s2">&quot;block_error&quot;</span>
<span class="sd">&quot;&quot;&quot;message type for error messages&quot;&quot;&quot;</span>

<span class="n">MSG_DELETE</span>  <span class="o">=</span> <span class="s2">&quot;delete&quot;</span>
<span class="sd">&quot;&quot;&quot;message type for delete messages&quot;&quot;&quot;</span>

<span class="n">PIPELINE_SOURCE_TYPE</span> <span class="o">=</span> <span class="s2">&quot;pipeline&quot;</span>

<span class="n">ILLEGAL_VAR_NAMES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;fetch&#39;</span><span class="p">,</span><span class="s1">&#39;skip_enforcement&#39;</span><span class="p">]</span>
<span class="sd">&quot;&quot;&quot;illegal or reserved names for variables in the graph&quot;&quot;&quot;</span>

<div class="viewcode-block" id="Pipeline"><a class="viewcode-back" href="../../../api/imagepypelines.Pipeline.html#imagepypelines.Pipeline">[docs]</a><span class="k">class</span> <span class="nc">Pipeline</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;processing algorithm manager for simple pipeline construction</span>

<span class="sd">    &lt; RYAN I NEED YOU HERE &gt;</span>


<span class="sd">    Attributes:</span>
<span class="sd">        uuid(str): hex uuid for this pipeline</span>
<span class="sd">        name(str): user specified name for this pipeline, used to generate</span>
<span class="sd">            the unique id. defaults to &quot;Pipeline&quot; or the name of your subclass</span>
<span class="sd">        logger(:obj:`ImagepypelinesLogger`): Logger object for this pipeline</span>
<span class="sd">        graph(:obj:`networkx.MultiDiGraph`): Multi-Edge directed task graph</span>
<span class="sd">            which stores all data and algorithmic order</span>
<span class="sd">        vars(dict): dict to track the block that generates the each variable,</span>
<span class="sd">            keys are variable names, values are a subdictionary containing</span>
<span class="sd">            &#39;block_node_id&#39; and &#39;block&#39;</span>
<span class="sd">        indexed_inputs(:obj:`list` of :obj:&#39;str&#39;): sorted list of indexed input</span>
<span class="sd">            variable names. (the indexed arguments for the process function)</span>
<span class="sd">        keyword_inputs(:obj:`list` of :obj:&#39;str&#39;): alphabetically sorted list of</span>
<span class="sd">            unindexed input variable names (the keyword arguments for the</span>
<span class="sd">            process function)</span>
<span class="sd">        _inputs(dict): dictionary internally used to access Input objects for</span>
<span class="sd">            queuing data into the pipeline</span>

<span class="sd">    Pipeline Graph Information:</span>
<span class="sd">        Nodes are dictionaries representing tasks. They contain:</span>
<span class="sd">            &#39;block&#39;   : block object for this task,</span>
<span class="sd">            &#39;args&#39;    : names of the task inputs for this block,</span>
<span class="sd">            &#39;outputs&#39; : names of the task outputs produced by this block,</span>
<span class="sd">            &#39;name&#39;    : string name of the node for visualization purposes,</span>
<span class="sd">            &#39;color&#39;   : color of the node for visualization purposes,</span>
<span class="sd">            &#39;shape&#39;   : shape of the node for visualization purposes,</span>
<span class="sd">            &#39;class_name&#39; : name of the class, frequently identical to the name</span>
<span class="sd">            &#39;validation_time&#39;: time required to validate incoming data if applicable</span>
<span class="sd">            &#39;processing_time&#39; : time required to process the data using this node</span>
<span class="sd">            &#39;avg_time_per_datum&#39;: average processing time for each datum</span>
<span class="sd">            &#39;num_in&#39; : number of datums coming into this node</span>
<span class="sd">            &#39;n_batches&#39; : number of batches for this node</span>
<span class="sd">            &#39;pid&#39; : process id for this node</span>
<span class="sd">            &#39;status&#39;: processing status. one of: (&#39;not started&#39;, &#39;processing&#39;, &#39;done&#39;)</span>
<span class="sd">            &lt;plus other attributes defined by the user in Block.get_default_node_attrs()&gt;</span>

<span class="sd">        Pipeline edges are dictionaries containing the following:</span>
<span class="sd">            &#39;var_name&#39;        : name of the variable in task definition</span>
<span class="sd">            &#39;out_index&#39;       : output index from the source node,</span>
<span class="sd">            &#39;in_index&#39;        : input index for the target node,</span>
<span class="sd">            &#39;name&#39;            : name target block&#39;s argument at the in_index</span>
<span class="sd">            &#39;same_type_for_all_datums&#39;    : whether or not this data is a homogenus container</span>
<span class="sd">            &#39;data_stored_in&#39;  : the type of the container used to house the data (list, ndarray, etc)</span>
<span class="sd">            &#39;n_datums&#39;        : number of items of data in this edge</span>
<span class="sd">            &#39;datum_type&#39;      : the type of data contained, this is only</span>
<span class="sd">                                guarenteed to be accurate is same_type_for_all_datums is True</span>
<span class="sd">            &#39;node_a&#39;          : source node uuid</span>
<span class="sd">            &#39;node_b&#39;          : target node uuid</span>
<span class="sd">            &#39;data&#39;            : data for this edge</span>




<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import imagepypelines as ip</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; @ip.blockify( kwargs=dict(value=10) )</span>
<span class="sd">        &gt;&gt;&gt; def add_val(a,b,value):</span>
<span class="sd">        &gt;&gt;&gt;     return a+value, b+value</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; @ip.blockify( kwargs=dict(value=5) )</span>
<span class="sd">        &gt;&gt;&gt; def minus_val(a,b,value):</span>
<span class="sd">        &gt;&gt;&gt;     return a-value, b-value</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; tasks = {</span>
<span class="sd">        &gt;&gt;&gt;         # inputs</span>
<span class="sd">        &gt;&gt;&gt;         &#39;zero&#39; : ip.Input(0),</span>
<span class="sd">        &gt;&gt;&gt;         &#39;one&#39; : ip.Input(1),</span>
<span class="sd">        &gt;&gt;&gt;         # operations</span>
<span class="sd">        &gt;&gt;&gt;         (&#39;ten&#39;,&#39;eleven&#39;) : (add_val, &#39;zero&#39;, &#39;one&#39;),</span>
<span class="sd">        &gt;&gt;&gt;         (&#39;twenty&#39;,&#39;eleven2&#39;) : (add_val, &#39;ten&#39;, &#39;one&#39;),</span>
<span class="sd">        &gt;&gt;&gt;         (&#39;fifteen&#39;, &#39;six&#39;) : (minus_val, &#39;twenty&#39;, &#39;eleven&#39;),</span>
<span class="sd">        &gt;&gt;&gt;         (&#39;twentyfive&#39;,&#39;twentyone&#39;) : (add_val, &#39;fifteen&#39;,&#39;eleven2&#39;),</span>
<span class="sd">        &gt;&gt;&gt;         (&#39;negativefour&#39;, &#39;negativefive&#39;) : (minus_val, &#39;one&#39;, &#39;zero&#39;),</span>
<span class="sd">        &gt;&gt;&gt;         }</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # pipeline1 - raw construction</span>
<span class="sd">        &gt;&gt;&gt; pipeline1 = ip.Pipeline(tasks, &#39;Pipeline1&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # pipeline1.draw(show=True)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; processed1 = pipeline1.process([0,0], [1,1])</span>
<span class="sd">        &gt;&gt;&gt; # print(processed1)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # pipeline2 - construction from task dict</span>
<span class="sd">        &gt;&gt;&gt; static_constructor = pipeline1.get_tasks()</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; pipeline2 = ip.Pipeline(static_constructor, name=&quot;Pipeline2&quot;)</span>
<span class="sd">        &gt;&gt;&gt; processed2 = pipeline2.process([0,0], one=[1,1])</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tasks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;initializes the pipeline with a user-provided graph (tasks)</span>

<span class="sd">        Args:</span>
<span class="sd">            tasks (dict,:obj:`Pipeline`): dictionary of tasks to define this</span>
<span class="sd">                pipeline&#39;s graph or another pipeline to replicate.</span>
<span class="sd">            name (str): name used to generate the logger name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uuid</span> <span class="o">=</span> <span class="n">uuid4</span><span class="p">()</span><span class="o">.</span><span class="n">hex</span> <span class="c1"># unique univeral hex ID for this pipeline</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="c1"># string name - used to generate the id</span>

        <span class="c1"># build the logger for this pipeline</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">get_logger</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">pipeline</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span> <span class="c1"># logging object</span>

        <span class="c1"># GRAPHING</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">()</span> <span class="c1"># networkx graph keeping track of tasks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vars</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># dict of var_names and the nodes that create them</span>

        <span class="c1"># PROCESS / internal tracking</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indexed_inputs</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># sorted list of indexed input variable names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyword_inputs</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># alphabetically sorted list of unindexed inputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># dict of input_name: Input_object</span>

        <span class="c1"># If a pipeline is passed in, then retrieve tasks and replicate our</span>
        <span class="c1"># pipeline</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tasks</span><span class="p">,</span> <span class="n">Pipeline</span><span class="p">):</span>
            <span class="n">tasks</span> <span class="o">=</span> <span class="n">tasks</span><span class="o">.</span><span class="n">get_tasks</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tasks</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">tasks</span> <span class="o">=</span> <span class="n">tasks</span>
        <span class="k">elif</span> <span class="n">tasks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tasks</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;tasks&#39; not a valid Pipeline, task graph dictionary, nor &#39;None&#39;.&quot;</span><span class="p">)</span>

        <span class="c1"># build the dashboard comm object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dashcomm</span> <span class="o">=</span> <span class="n">DashboardComm</span><span class="p">()</span>

        <span class="c1"># update the tasks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tasks</span><span class="p">)</span>


    <span class="c1">############################################################################</span>
    <span class="c1">#                       primary frontend functions</span>
    <span class="c1">############################################################################</span>
<div class="viewcode-block" id="Pipeline.update"><a class="viewcode-back" href="../../../api/imagepypelines.Pipeline.html#imagepypelines.Pipeline.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tasks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">predict_compatibility</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;updates the pipeline&#39;s graph with a dict of tasks</span>

<span class="sd">        `update` will modify and change many instance variables of the pipeline.</span>
<span class="sd">        Despite its generic name, it can only add tasks to the pipeline, not</span>
<span class="sd">        remove them. `update` is called internally to the pipeline during</span>
<span class="sd">        instantiation.</span>

<span class="sd">        Args:</span>
<span class="sd">            tasks(dict): dictionary of tasks to define this pipeline&#39;s graph</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">########################################################################</span>
        <span class="c1">#                           HELPER FUNCTIONS</span>
        <span class="c1">########################################################################</span>
        <span class="k">def</span> <span class="nf">_add_to_vars</span><span class="p">(</span><span class="n">var</span><span class="p">):</span>
            <span class="c1"># make sure variable name is a string</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;graph vars must be a string, not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">var</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="c1"># check if variable name already exists</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;variable </span><span class="se">\&quot;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="se">\&quot;</span><span class="s2"> cannot be defined more than once&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="c1"># check if variable name is illegal</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">ILLEGAL_VAR_NAMES</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2"> cannot be named one of </span><span class="si">{</span><span class="n">ILLEGAL_VAR_NAMES</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">PipelineError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;block_node_id&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span> <span class="c1"># will always be defined</span>
                                <span class="s1">&#39;block&#39;</span><span class="p">:</span><span class="kc">None</span> <span class="c1"># will always be defined</span>
                                <span class="p">}</span>

        <span class="k">def</span> <span class="nf">_add_input</span><span class="p">(</span><span class="n">inpt</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">node_uuid</span><span class="p">):</span>
            <span class="c1"># track what inputs are required so we can populate</span>
            <span class="c1"># them with arguments in self.process</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Inputs must define exactly one output&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">PipelineError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="c1"># add the input block to a tracking dictionary</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="p">[</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">inpt</span>

        <span class="c1"># ======================================================================</span>
        <span class="c1">#                           GRAPH CONSTRUCTION</span>
        <span class="c1"># ======================================================================</span>

        <span class="k">if</span> <span class="n">tasks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tasks</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1">########################################################################</span>
        <span class="c1">#           Define the variables we&#39;ll be using for these tasks</span>
        <span class="c1">########################################################################</span>
        <span class="c1"># add all variables defined in the graph to a dictionary</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">tasks</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># for tuple defined dict keys like (&#39;x&#39;,&#39;y&#39;) : (block, &#39;a&#39;, &#39;b&#39;)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,(</span><span class="nb">tuple</span><span class="p">,</span><span class="nb">list</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">var</span><span class="p">:</span>
                    <span class="n">_add_to_vars</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

            <span class="c1"># for str defined dict keys like &#39;x&#39; : (block, &#39;a&#39;, &#39;b&#39;)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_add_to_vars</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>



        <span class="c1">########################################################################</span>
        <span class="c1">#                    Add all the task nodes to the graph</span>
        <span class="c1">########################################################################</span>
        <span class="c1"># reiterate through the graph definition to define inputs and outputs</span>
        <span class="k">for</span> <span class="n">outputs</span><span class="p">,</span><span class="n">task</span> <span class="ow">in</span> <span class="n">tasks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># make a single value into a list to simplify code</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span><span class="nb">list</span><span class="p">)):</span>
                <span class="n">outputs</span> <span class="o">=</span> <span class="p">(</span><span class="n">outputs</span><span class="p">,)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span><span class="nb">list</span><span class="p">)):</span>
                <span class="n">task</span> <span class="o">=</span> <span class="p">(</span><span class="n">task</span><span class="p">,)</span>

            <span class="c1"># e.g. - &#39;z&#39;: (block, &#39;x&#39;, &#39;y&#39;),</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span><span class="nb">list</span><span class="p">)):</span>
                <span class="n">block</span> <span class="o">=</span> <span class="n">task</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">task</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="n">node_uuid</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="n">uuid4</span><span class="p">()</span><span class="o">.</span><span class="n">hex</span> <span class="o">+</span> <span class="s1">&#39;-node&#39;</span>
                <span class="c1"># if we have a tuple input, then the first value MUST be a block</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">Block</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;first value in any graph definition tuple must be a Block&quot;</span><span class="p">)</span>

                <span class="c1"># check if this block is an &quot;Input&quot; Block - this is a special case</span>
                <span class="c1"># e.g. - &#39;x&#39;: (ip.Input(),)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">Input</span><span class="p">):</span>
                    <span class="n">_add_input</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">node_uuid</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">PipelineError</span><span class="p">(</span><span class="s2">&quot;Input blocks cannot take any arguments&quot;</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="p">[</span><span class="n">output</span><span class="p">][</span><span class="s1">&#39;block_node_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_uuid</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="p">[</span><span class="n">output</span><span class="p">][</span><span class="s1">&#39;block&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span>

                <span class="c1"># check this task&#39;s setup using the block.check_setup function</span>
                <span class="n">block</span><span class="o">.</span><span class="n">check_setup</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

                <span class="c1"># add the task to the graph</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node_uuid</span><span class="p">,</span>
                                    <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
                                    <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
                                    <span class="n">outputs</span><span class="o">=</span><span class="n">outputs</span><span class="p">,</span>
                                    <span class="n">validation_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">processing_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">avg_time_per_datum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">num_in</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">n_batches</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">pid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">status</span><span class="o">=</span><span class="n">STATUS_NOT_STARTED</span><span class="p">,</span>
                                    <span class="o">**</span><span class="n">block</span><span class="o">.</span><span class="n">get_default_node_attrs</span><span class="p">(),</span>
                                    <span class="p">)</span>


            <span class="k">else</span><span class="p">:</span> <span class="c1"># something other than a block or of tuple (block, var1, var2,...)</span>
                <span class="k">raise</span> <span class="n">PipelineError</span><span class="p">(</span><span class="s2">&quot;invalid task definition, must be block or tuple: (block, &#39;var1&#39;, &#39;var2&#39;,...)&quot;</span><span class="p">)</span>

        <span class="c1">########################################################################</span>
        <span class="c1">#             Draw any new edges required for all block nodes</span>
        <span class="c1">########################################################################</span>
        <span class="c1"># THIRD FOR LOOP - drawing edges</span>
        <span class="k">for</span> <span class="n">node_b</span><span class="p">,</span><span class="n">node_b_attrs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="c1"># draw an edge for every input into this node</span>
            <span class="k">for</span> <span class="n">in_index</span><span class="p">,</span> <span class="n">arg_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node_b_attrs</span><span class="p">[</span><span class="s1">&#39;args&#39;</span><span class="p">]):</span>
                <span class="c1"># first we identify an upstream node by looking up what task</span>
                <span class="c1"># created them</span>
                <span class="n">node_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="p">[</span><span class="n">arg_name</span><span class="p">][</span><span class="s1">&#39;block_node_id&#39;</span><span class="p">]</span>
                <span class="n">node_a_attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span> <span class="n">node_a</span> <span class="p">]</span>

                <span class="c1"># draw the edge FOR THIS INPUT from node_a to node_b</span>
                <span class="n">block_arg_name</span> <span class="o">=</span> <span class="n">node_b_attrs</span><span class="p">[</span><span class="s1">&#39;block&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">in_index</span><span class="p">]</span>
                <span class="n">out_index</span> <span class="o">=</span> <span class="n">node_a_attrs</span><span class="p">[</span><span class="s1">&#39;outputs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">arg_name</span><span class="p">)</span>

                <span class="c1"># edge key is {var_name}:{out_index}--&gt;{in_index}</span>
                <span class="n">edge_key</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">:</span><span class="si">{}</span><span class="s2">--&gt;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">arg_name</span><span class="p">,</span> <span class="n">out_index</span><span class="p">,</span> <span class="n">in_index</span><span class="p">)</span>

                <span class="c1"># draw the edge if it doesn&#39;t already exist</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">node_a</span><span class="p">,</span><span class="n">node_b</span><span class="p">,</span><span class="n">edge_key</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">node_a</span><span class="p">,</span>
                                        <span class="n">node_b</span><span class="p">,</span>
                                        <span class="c1"># key</span>
                                        <span class="n">key</span><span class="o">=</span><span class="n">edge_key</span><span class="p">,</span>
                                        <span class="c1"># attributes</span>
                                        <span class="n">var_name</span> <span class="o">=</span> <span class="n">arg_name</span><span class="p">,</span> <span class="c1"># name assigned in graph definition</span>
                                        <span class="n">out_index</span> <span class="o">=</span> <span class="n">out_index</span><span class="p">,</span>
                                        <span class="n">in_index</span> <span class="o">=</span> <span class="n">in_index</span><span class="p">,</span>
                                        <span class="n">name</span> <span class="o">=</span> <span class="n">block_arg_name</span><span class="p">,</span> <span class="c1"># name of node_b&#39;s process argument at the index</span>
                                        <span class="n">same_type_for_all_datums</span><span class="o">=</span><span class="s2">&quot;unknown&quot;</span><span class="p">,</span>
                                        <span class="n">n_datums</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                        <span class="n">datum_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                        <span class="n">data_stored_in</span><span class="o">=</span><span class="s2">&quot;unknown&quot;</span><span class="p">,</span>
                                        <span class="n">node_a</span> <span class="o">=</span> <span class="n">node_a</span><span class="p">,</span>
                                        <span class="n">node_b</span> <span class="o">=</span> <span class="n">node_b</span><span class="p">,</span>
                                        <span class="n">data</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="c1"># none is a placeholder value. it will be populated</span>
                                        <span class="p">)</span>


        <span class="c1">########################################################################</span>
        <span class="c1">#             Draw &#39;leaves&#39; on tasks with no output edges</span>
        <span class="c1">#             this is required so they will still be computable</span>
        <span class="c1">########################################################################</span>
        <span class="c1"># this is required so we can store data on end edges - otherwise the final</span>
        <span class="c1"># nodes of our pipeline won&#39;t have output edges, so we can&#39;t store data</span>
        <span class="c1"># on those edges</span>

        <span class="c1"># make a list of nodes without outgoing edges</span>
        <span class="n">end_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node_id</span><span class="p">,</span><span class="n">attrs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="c1"># if the node already has outputs, we don&#39;t need a leaf out of it</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">out_degree</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;outputs&#39;</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="c1"># if the end node is a Leaf already, then we don&#39;t need another leaf</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;block&#39;</span><span class="p">],</span><span class="n">Leaf</span><span class="p">):</span>
                    <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bad_edges</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">drawn_edges</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">out_edges</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="s1">&#39;var_name&#39;</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;outputs&#39;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">var_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">drawn_edges</span><span class="p">:</span>
                        <span class="n">bad_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_name</span><span class="p">)</span>

                <span class="n">end_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">node_id</span><span class="p">,</span><span class="n">attrs</span><span class="p">,</span><span class="n">bad_edges</span><span class="p">)</span> <span class="p">)</span>

        <span class="k">for</span> <span class="n">node_id</span><span class="p">,</span><span class="n">node_attrs</span><span class="p">,</span><span class="n">bad_edges</span> <span class="ow">in</span> <span class="n">end_nodes</span><span class="p">:</span>
            <span class="c1"># this is a final node of the pipeline, so we need to draw a</span>
            <span class="c1"># leaf for each of its output edges</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">end_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bad_edges</span><span class="p">):</span>
                <span class="c1"># add the leaf</span>
                <span class="n">leaf</span> <span class="o">=</span> <span class="n">Leaf</span><span class="p">(</span><span class="n">end_name</span><span class="p">)</span>
                <span class="n">leaf_uuid</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="n">uuid4</span><span class="p">()</span><span class="o">.</span><span class="n">hex</span> <span class="o">+</span> <span class="s1">&#39;-node&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">leaf_uuid</span><span class="p">,</span>
                                    <span class="n">block</span><span class="o">=</span><span class="n">leaf</span><span class="p">,</span>
                                    <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">end_name</span><span class="p">,),</span>
                                    <span class="n">outputs</span><span class="o">=</span><span class="p">(</span><span class="n">end_name</span><span class="p">,),</span>
                                    <span class="n">validation_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">processing_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">avg_time_per_datum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">num_in</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">n_batches</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">pid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">status</span><span class="o">=</span><span class="n">STATUS_NOT_STARTED</span><span class="p">,</span>
                                    <span class="o">**</span><span class="n">leaf</span><span class="o">.</span><span class="n">get_default_node_attrs</span><span class="p">()</span>
                                    <span class="p">)</span>

                <span class="c1"># edge key is {var_name}:{out_index}--&gt;{in_index}</span>
                <span class="n">edge_key</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">:</span><span class="si">{}</span><span class="s2">--&gt;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">end_name</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="c1"># draw the edge to the leaf</span>
                <span class="c1"># no need to check if it exists, because we just created the Leaf</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span>
                                    <span class="n">leaf_uuid</span><span class="p">,</span>
                                    <span class="n">key</span><span class="o">=</span><span class="n">edge_key</span><span class="p">,</span>
                                    <span class="n">var_name</span><span class="o">=</span><span class="n">end_name</span><span class="p">,</span> <span class="c1"># name assigned in graph definition</span>
                                    <span class="n">out_index</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                                    <span class="n">in_index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                    <span class="n">name</span><span class="o">=</span><span class="n">end_name</span><span class="p">,</span> <span class="c1"># name of node_b&#39;s process argument at the index</span>
                                    <span class="n">same_type_for_all_datums</span><span class="o">=</span><span class="s2">&quot;unknown&quot;</span><span class="p">,</span>
                                    <span class="n">n_datums</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                    <span class="n">datum_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">data_stored_in</span><span class="o">=</span><span class="s2">&quot;unknown&quot;</span><span class="p">,</span>
                                    <span class="n">node_a</span> <span class="o">=</span> <span class="n">node_id</span><span class="p">,</span>
                                    <span class="n">node_b</span> <span class="o">=</span> <span class="n">leaf_uuid</span><span class="p">,</span>
                                    <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>



        <span class="c1"># CHECK to make sure the graph isn&#39;t cyclic (this is impossible to compute)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nx</span><span class="o">.</span><span class="n">is_directed_acyclic_graph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Cyclic variable dependency detected! Make sure&quot;</span> \
                        <span class="s2">&quot; two variables don&#39;t depend on each other - these&quot;</span> \
                        <span class="s2">&quot; aren&#39;t possible to compute&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">PipelineError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>


        <span class="c1">########################################################################</span>
        <span class="c1">#                   create input list &amp; requirements</span>
        <span class="c1">########################################################################</span>
        <span class="c1"># reset old index tracking lists</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indexed_inputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyword_inputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># sort the inputs into keyword and indexed</span>
        <span class="k">for</span> <span class="n">inpt_name</span><span class="p">,</span> <span class="n">inpt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># check if the input index is defined</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inpt</span><span class="o">.</span><span class="n">index</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">indexed_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inpt_name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">keyword_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inpt_name</span><span class="p">)</span>

        <span class="c1"># sort the positonal inputs by index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indexed_inputs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="c1"># sort keyword only inputs alphabetically</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyword_inputs</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>


        <span class="c1"># check to make sure an input index isn&#39;t defined twice</span>
        <span class="n">indices_used</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexed_inputs</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">indices_used</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices_used</span><span class="p">):</span>
            <span class="c1"># Note: add more verbose error message</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Input indices cannot be reused&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">PipelineError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># check to make sure input indexes are consecutive (don&#39;t skip)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices_used</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">indices_used</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices_used</span><span class="p">):</span>
                <span class="c1"># Note: add more verbose error message</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Input indices must be consecutive&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">PipelineError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># log the current pipeline status</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> tasks set up; process arguments are (</span><span class="si">{}</span><span class="s2">,)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tasks</span><span class="p">),</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1">########################################################################</span>
        <span class="c1">#                       Running Checks</span>
        <span class="c1">########################################################################</span>

        <span class="k">if</span> <span class="n">predict_compatibility</span><span class="p">:</span>
            <span class="c1"># check to make sure there are compatible types</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="c1"># check if there are compatible types</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_types_for</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">():</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;PREDICTED INCOMPATIBILITY : no compatible types for &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">var</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="c1"># check if there are compatible shapes</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shapes_for</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">():</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;PREDICTED INCOMPATIBILITY : no compatible shapes for &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">var</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>


        <span class="c1"># iterate through edges and check if any blocks are expecting void data</span>
        <span class="k">for</span> <span class="n">node_a_id</span><span class="p">,</span> <span class="n">node_b_id</span><span class="p">,</span> <span class="n">var_name</span>  <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s2">&quot;var_name&quot;</span><span class="p">):</span>
            <span class="n">block_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_a_id</span><span class="p">][</span><span class="s1">&#39;block&#39;</span><span class="p">]</span>
            <span class="n">block_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_b_id</span><span class="p">][</span><span class="s1">&#39;block&#39;</span><span class="p">]</span>

            <span class="c1"># if block a is void, then we make sure block_b isn&#39;t a block</span>
            <span class="c1"># expecting data that won&#39;t exist (make sure block b isn&#39;t a leaf)</span>
            <span class="k">if</span> <span class="n">block_a</span><span class="o">.</span><span class="n">void</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">block_b</span><span class="p">,</span> <span class="n">Leaf</span><span class="p">):</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;INCOMPATIBILE EDGE: </span><span class="si">{block_b}</span><span class="s2"> is expecting &#39;</span><span class="si">{var_name}</span><span class="s2">&#39; from </span><span class="si">{block_a}</span><span class="s2">, but </span><span class="si">{block_a}</span><span class="s2"> is void (doesn&#39;t return data)&quot;</span>
                    <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">block_a</span><span class="o">=</span><span class="n">block_a</span><span class="p">,</span>
                                <span class="n">block_b</span><span class="o">=</span><span class="n">block_b</span><span class="p">,</span>
                                <span class="n">var_name</span><span class="o">=</span><span class="n">var_name</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># print warning for vars that won&#39;t be computed</span>
        <span class="n">noncomputable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">noncomputable</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">noncomputable</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">noncomputable</span><span class="si">}</span><span class="s2"> won&#39;t be computed because they rely on data from void blocks (blocks that don&#39;t return data)&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># send along the new graph in a message to the Dashboards</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__send_graph_msg_to_dash</span><span class="p">()</span></div>


    <span class="c1">############################################################################</span>
<div class="viewcode-block" id="Pipeline.process"><a class="viewcode-back" href="../../../api/imagepypelines.Pipeline.html#imagepypelines.Pipeline.process">[docs]</a>    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">pos_data</span><span class="p">,</span> <span class="n">fetch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skip_enforcement</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwdata</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;processes input data through the pipeline</span>

<span class="sd">        process first resets this pipeline, before loading input data into the</span>
<span class="sd">        graph and processing it.</span>

<span class="sd">        Note:</span>
<span class="sd">            The argument list for the Pipeline can be found with `Pipeline.args`</span>

<span class="sd">        Warning:</span>
<span class="sd">            MUST ADD FETCHES DOCUMENTATIONS</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup fetches</span>
        <span class="k">if</span> <span class="n">fetch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fetch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

        <span class="c1"># clear any data already in the graph, and send a message to the dashboard(s)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

        <span class="c1"># --------------------------------------------------------------</span>
        <span class="c1"># STORING INPUTS - inside the input nodes</span>
        <span class="c1"># --------------------------------------------------------------</span>
        <span class="n">all_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span>
        <span class="c1"># store positonal arguments fed in</span>
        <span class="c1">## NOTE: need error checking here (number of inputs, etc)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pos_data</span><span class="p">):</span>
            <span class="n">inpt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="p">[</span> <span class="n">all_inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">]</span>
            <span class="c1"># check if the data has already been loaded</span>
            <span class="k">if</span> <span class="n">inpt</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; has already been loaded&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexed_inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">PipelineError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">inpt</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># store keyword arguments fed in</span>
        <span class="c1">## NOTE: need error checking here (number of inputs, etc)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">kwdata</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">inpt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="c1"># check if the data has already been loaded</span>
            <span class="k">if</span> <span class="n">inpt</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; has already been loaded&quot;</span> <span class="o">%</span> <span class="n">key</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">PipelineError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">inpt</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="c1"># check to make sure all inputs are loaded</span>
        <span class="n">data_loaded</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">inpt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">inpt</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;data for </span><span class="se">\&quot;</span><span class="si">%s</span><span class="se">\&quot;</span><span class="s2"> must be provided&quot;</span> <span class="o">%</span> <span class="n">key</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="n">data_loaded</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">data_loaded</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">PipelineError</span><span class="p">(</span><span class="s2">&quot;insufficient input data provided&quot;</span><span class="p">)</span>

        <span class="c1"># --------------------------------------------------------------</span>
        <span class="c1"># PROCESS</span>
        <span class="c1"># --------------------------------------------------------------</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__compute</span><span class="p">(</span><span class="n">skip_enforcement</span><span class="p">)</span>

        <span class="c1"># populate the output dictionary</span>
        <span class="n">fetch_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">edge</span><span class="p">[</span><span class="s1">&#39;var_name&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">fetch</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">edge</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">fetch_dict</span><span class="p">[</span> <span class="n">edge</span><span class="p">[</span><span class="s1">&#39;var_name&#39;</span><span class="p">]</span> <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1">#Could eventually be ip.Void or ip.NULL type</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fetch_dict</span><span class="p">[</span> <span class="n">edge</span><span class="p">[</span><span class="s1">&#39;var_name&#39;</span><span class="p">]</span> <span class="p">]</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">grab</span><span class="p">()</span>

        <span class="c1"># clear the graph of data to reduce memory footprint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">fetch_dict</span></div>

    <span class="c1">############################################################################</span>
<div class="viewcode-block" id="Pipeline.process_and_grab"><a class="viewcode-back" href="../../../api/imagepypelines.Pipeline.html#imagepypelines.Pipeline.process_and_grab">[docs]</a>    <span class="k">def</span> <span class="nf">process_and_grab</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">pos_data</span><span class="p">,</span> <span class="n">fetch</span><span class="p">,</span> <span class="n">skip_enforcement</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwdata</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;processes input data through the pipeline, but returns a tuple with</span>
<span class="sd">        the specified fetches</span>

<span class="sd">        process first resets this pipeline, before loading input data into the</span>
<span class="sd">        graph and processing it.</span>

<span class="sd">        Note:</span>
<span class="sd">            The argument list for the Pipeline can be found with `Pipeline.args`</span>

<span class="sd">        Warning:</span>
<span class="sd">            MUST ADD FETCHES DOCUMENTATIONS</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">fetch_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="o">*</span><span class="n">pos_data</span><span class="p">,</span>
                                    <span class="n">fetch</span><span class="o">=</span><span class="n">fetch</span><span class="p">,</span>
                                    <span class="n">skip_enforcement</span><span class="o">=</span><span class="n">skip_enforcement</span><span class="p">,</span>
                                    <span class="o">**</span><span class="n">kwdata</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span> <span class="n">fetch_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">fetch</span> <span class="p">)</span></div>

    <span class="c1">############################################################################</span>
<div class="viewcode-block" id="Pipeline.asblock"><a class="viewcode-back" href="../../../api/imagepypelines.Pipeline.html#imagepypelines.Pipeline.asblock">[docs]</a>    <span class="k">def</span> <span class="nf">asblock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">fetches</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;generates a block that runs this pipeline internally</span>

<span class="sd">        Args:</span>
<span class="sd">            *fetches: variables to fetch from the pipeline in the order they</span>
<span class="sd">                should be outputed as</span>

<span class="sd">        Returns:</span>
<span class="sd">            :obj:`Block`: Block which will run the pipeline internally and</span>
<span class="sd">                retrieve the data specified by fetches</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">PipelineBlock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fetch</span><span class="o">=</span><span class="n">fetches</span><span class="p">)</span></div>

    <span class="c1">############################################################################</span>
<div class="viewcode-block" id="Pipeline.clear"><a class="viewcode-back" href="../../../api/imagepypelines.Pipeline.html#imagepypelines.Pipeline.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;clears all edges in the graph and unloads the input nodes. Does not</span>
<span class="sd">        update the remote dashboard&quot;&quot;&quot;</span>
        <span class="c1"># unload all edge data</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">edge</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># unload all input data</span>
        <span class="k">for</span> <span class="n">inpt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">inpt</span><span class="o">.</span><span class="n">unload</span><span class="p">()</span></div>

    <span class="c1">############################################################################</span>
<div class="viewcode-block" id="Pipeline.reset"><a class="viewcode-back" href="../../../api/imagepypelines.Pipeline.html#imagepypelines.Pipeline.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;resets all edges in the graph, resets the inputs (and updates the dashboards)&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="c1"># send a message to the dashboards saying the pipeline has been reset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__send_reset_msg_to_dash</span><span class="p">()</span></div>

    <span class="c1">############################################################################</span>
<div class="viewcode-block" id="Pipeline.draw"><a class="viewcode-back" href="../../../api/imagepypelines.Pipeline.html#imagepypelines.Pipeline.draw">[docs]</a>    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># visualize(self, show, ax)</span>
        <span class="k">pass</span></div>

    <span class="c1"># saving/loading</span>
    <span class="c1">############################################################################</span>
<div class="viewcode-block" id="Pipeline.save"><a class="viewcode-back" href="../../../api/imagepypelines.Pipeline.html#imagepypelines.Pipeline.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">passwd</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;serializes and saves a copy of the pipeline to the given filename.</span>
<span class="sd">        Pipeline can be optionally encrypted</span>

<span class="sd">        Args:</span>
<span class="sd">            filename(str): the filename to save the serialized pipeline to</span>
<span class="sd">            passwd(str): password to encrypt the serialized pipeline with if</span>
<span class="sd">                desired, defaults to None</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: the sha256 checksum for the saved file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">encoded</span><span class="p">,</span> <span class="n">checksum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="n">passwd</span><span class="p">)</span>
        <span class="c1"># write the file contents</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">encoded</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">checksum</span></div>

    <span class="c1">############################################################################</span>
<div class="viewcode-block" id="Pipeline.load"><a class="viewcode-back" href="../../../api/imagepypelines.Pipeline.html#imagepypelines.Pipeline.load">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">passwd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;loads the pipeline from the given file</span>

<span class="sd">        Args:</span>
<span class="sd">            filename(str): the filename to load the serialized pipeline from</span>
<span class="sd">            passwd(str): password to decrypt the serialized pipeline with, defaults</span>
<span class="sd">                to None</span>
<span class="sd">            checksum(str): the sha256 checksum to check the file against</span>
<span class="sd">            name(str): new name for the pipeline. If left as None, then</span>
<span class="sd">                defaults to the old name of the pipeline</span>

<span class="sd">        Returns:</span>
<span class="sd">            :obj:`Pipeline`: the loaded pipeline</span>

<span class="sd">        Warning:</span>
<span class="sd">            Serilized data can be a security risk! For sensitive applications,</span>
<span class="sd">            use the `checksum` parameter. ImagePypelines can use this to ensure</span>
<span class="sd">            the data hasn&#39;t been tampered with.</span>

<span class="sd">            for more information about serialization security, see:</span>
<span class="sd">            https://docs.python.org/3.8/library/pickle.html</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># fetch the raw file contents</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">raw_bytes</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">raw_bytes</span><span class="p">,</span> <span class="n">passwd</span><span class="p">,</span> <span class="n">checksum</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></div>

    <span class="c1">############################################################################</span>
<div class="viewcode-block" id="Pipeline.to_bytes"><a class="viewcode-back" href="../../../api/imagepypelines.Pipeline.html#imagepypelines.Pipeline.to_bytes">[docs]</a>    <span class="k">def</span> <span class="nf">to_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">passwd</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;serialized a copy of the pipeline, and returns the raw bytes. Can be</span>
<span class="sd">        optionally encrypted</span>

<span class="sd">        Args:</span>
<span class="sd">            passwd(str): password to encrypt the serialized pipeline with if</span>
<span class="sd">                desired, defaults to None</span>
<span class="sd">        Returns:</span>
<span class="sd">            (tuple): tuple containing:</span>

<span class="sd">                bytes: the serialized and optionally encrypted pipeline</span>
<span class="sd">                str: the sha256 checksum for the raw bytes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">raw_bytes</span> <span class="o">=</span> <span class="n">dill</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

        <span class="c1"># encrypt the pipeline if passwd is provided</span>
        <span class="k">if</span> <span class="n">passwd</span><span class="p">:</span>
            <span class="n">fernet</span> <span class="o">=</span> <span class="n">Fernet</span><span class="p">(</span> <span class="n">passgen</span><span class="p">(</span><span class="n">passwd</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">encoded</span> <span class="o">=</span> <span class="n">fernet</span><span class="o">.</span><span class="n">encrypt</span><span class="p">(</span><span class="n">raw_bytes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">encoded</span> <span class="o">=</span> <span class="n">raw_bytes</span>

        <span class="k">return</span> <span class="n">encoded</span><span class="p">,</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha256</span><span class="p">(</span><span class="n">encoded</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span></div>

    <span class="c1">############################################################################</span>
<div class="viewcode-block" id="Pipeline.from_bytes"><a class="viewcode-back" href="../../../api/imagepypelines.Pipeline.html#imagepypelines.Pipeline.from_bytes">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_bytes</span><span class="p">(</span><span class="n">raw_bytes</span><span class="p">,</span> <span class="n">passwd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;loads the pipeline from the given bytes</span>

<span class="sd">        Args:</span>
<span class="sd">            raw_bytes(bytes): the encoded pipeline in bytes format</span>
<span class="sd">            passwd(str): password to decrypt the serialized pipeline with, defaults</span>
<span class="sd">                to None</span>
<span class="sd">            checksum(str): the sha256 checksum to check the bytes against</span>
<span class="sd">            name(str): new name for the pipeline. If left as None, then</span>
<span class="sd">                defaults to the old name of the pipeline</span>

<span class="sd">        Returns:</span>
<span class="sd">            :obj:`Pipeline`: the loaded pipeline</span>

<span class="sd">        Warning:</span>
<span class="sd">            Serialized data can be a security risk! For sensitive applications,</span>
<span class="sd">            use the `checksum` parameter. ImagePypelines can use this to ensure</span>
<span class="sd">            the data hasn&#39;t been tampered with.</span>

<span class="sd">            for more information about serialization security, see:</span>
<span class="sd">            https://docs.python.org/3.8/library/pickle.html</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check the file checksum if provided</span>
        <span class="k">if</span> <span class="n">checksum</span><span class="p">:</span>
            <span class="n">fchecksum</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha256</span><span class="p">(</span><span class="n">raw_bytes</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">fchecksum</span> <span class="o">!=</span> <span class="n">checksum</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Invalid Checksum!&quot;</span>
                <span class="n">MASTER_LOGGER</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="n">PipelineError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># decrypt the file contents if passwd is provided</span>
        <span class="k">if</span> <span class="n">passwd</span><span class="p">:</span>
            <span class="n">fernet</span> <span class="o">=</span> <span class="n">Fernet</span><span class="p">(</span> <span class="n">passgen</span><span class="p">(</span><span class="n">passwd</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">decoded</span> <span class="o">=</span> <span class="n">fernet</span><span class="o">.</span><span class="n">decrypt</span><span class="p">(</span><span class="n">raw_bytes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">decoded</span> <span class="o">=</span> <span class="n">raw_bytes</span>

        <span class="c1"># load the pipeline</span>
        <span class="n">pipeline</span> <span class="o">=</span> <span class="n">dill</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">decoded</span><span class="p">)</span>

        <span class="c1"># rename it if desired</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pipeline</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pipeline</span></div>

    <span class="c1">############################################################################</span>
<div class="viewcode-block" id="Pipeline.copy"><a class="viewcode-back" href="../../../api/imagepypelines.Pipeline.html#imagepypelines.Pipeline.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns a copy of the Pipeline, but not a copy of the blocks&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="n">Pipeline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>

    <span class="c1">############################################################################</span>
<div class="viewcode-block" id="Pipeline.deepcopy"><a class="viewcode-back" href="../../../api/imagepypelines.Pipeline.html#imagepypelines.Pipeline.deepcopy">[docs]</a>    <span class="k">def</span> <span class="nf">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns a copy of the Pipeline including copies of all its blocks&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="c1"># iterate through all pipeline tasks</span>
        <span class="n">already_copied</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">new_tasks</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># for (&#39;out1&#39;, &#39;out2&#39;), (block, &#39;in1&#39;, &#39;in2&#39;)</span>
        <span class="k">for</span> <span class="n">task_outs</span><span class="p">,</span> <span class="n">task_ins</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_tasks</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">old_block</span> <span class="o">=</span> <span class="n">task_ins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">task_ins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

            <span class="c1"># if block is already copied, fetch the copied block for the new tasks</span>
            <span class="k">if</span> <span class="n">old_block</span><span class="o">.</span><span class="n">uuid</span> <span class="ow">in</span> <span class="n">already_copied</span><span class="p">:</span>
                <span class="n">new_block</span> <span class="o">=</span> <span class="n">already_copied</span><span class="p">[</span><span class="n">old_block</span><span class="o">.</span><span class="n">uuid</span><span class="p">]</span>
            <span class="c1"># otherwise copy the block if we haven&#39;t already copied it</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_block</span> <span class="o">=</span> <span class="n">old_block</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
                <span class="n">already_copied</span><span class="p">[</span><span class="n">old_block</span><span class="o">.</span><span class="n">uuid</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_block</span>

            <span class="n">new_tasks</span><span class="p">[</span><span class="n">task_outs</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_block</span><span class="p">,)</span> <span class="o">+</span> <span class="n">args</span>

        <span class="k">return</span> <span class="n">Pipeline</span><span class="p">(</span><span class="n">new_tasks</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>


    <span class="c1">############################################################################</span>
    <span class="c1">#                               internal</span>
    <span class="c1">############################################################################</span>
    <span class="k">def</span> <span class="nf">__format_edge_data_for_dash_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;formats data for an edge to a sendable form,</span>

<span class="sd">        Relies on a copy of the edge being passed in so permanent changes to</span>
<span class="sd">        the graph aren&#39;t made</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># delete the data from edge - we don&#39;t need it</span>
        <span class="k">del</span> <span class="n">edge_data</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
        <span class="c1"># convert classes to their strings names</span>
        <span class="n">edge_data</span><span class="p">[</span><span class="s1">&#39;datum_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_data</span><span class="p">[</span><span class="s1">&#39;datum_type&#39;</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">edge_data</span><span class="p">[</span><span class="s1">&#39;data_stored_in&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_data</span><span class="p">[</span><span class="s1">&#39;data_stored_in&#39;</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">return</span> <span class="n">edge_data</span>

    <span class="k">def</span> <span class="nf">__send_graph_msg_to_dash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;sends a full description of the graph to the dashboard</span>

<span class="sd">        This includes the graph structure and documentation for all blocks</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">payload</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">payload</span><span class="p">[</span><span class="s1">&#39;args&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span>

        <span class="c1"># commented out as redundant on 07/12/20 - JM</span>
        <span class="c1"># # variables and the node id that creates them</span>
        <span class="c1"># vars = {key : val[&#39;block_node_id&#39;] for key,val in self.vars.items()}</span>
        <span class="c1"># payload[&quot;vars&quot;] = vars</span>

        <span class="c1"># create a dictionary containing block summaries</span>
        <span class="n">payload</span><span class="p">[</span><span class="s1">&#39;block_docs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="p">:</span>
            <span class="n">payload</span><span class="p">[</span><span class="s1">&#39;block_docs&#39;</span><span class="p">][</span><span class="n">block</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">_summary</span><span class="p">()</span>

        <span class="c1"># copy the graph so we can modify it safely</span>
        <span class="n">graph_copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># populate the nodes metadata</span>
        <span class="n">payload</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">node_id</span><span class="p">,</span><span class="n">node_info</span> <span class="ow">in</span> <span class="n">graph_copy</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="c1"># delete the block from this copy - we don&#39;t need it</span>
            <span class="k">del</span> <span class="n">node_info</span><span class="p">[</span><span class="s1">&#39;block&#39;</span><span class="p">]</span>
            <span class="n">payload</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">][</span><span class="n">node_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_info</span>

        <span class="c1"># populate the edge metadata</span>
        <span class="n">payload</span><span class="p">[</span><span class="s1">&#39;edges&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">node_a</span><span class="p">,</span><span class="n">node_b</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">e_data</span> <span class="ow">in</span> <span class="n">graph_copy</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">e_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__format_edge_data_for_dash_msg</span><span class="p">(</span><span class="n">e_data</span><span class="p">)</span>
            <span class="n">payload</span><span class="p">[</span><span class="s1">&#39;edges&#39;</span><span class="p">][</span><span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">node_a</span><span class="p">,</span><span class="n">node_b</span><span class="p">,</span><span class="n">key</span><span class="p">))]</span> <span class="o">=</span> <span class="n">e_data</span>


        <span class="c1"># jsonify the graph in node-link format. see:</span>
        <span class="c1"># https://networkx.github.io/documentation/stable/reference/readwrite/json_graph.html</span>
        <span class="n">payload</span><span class="p">[</span><span class="s1">&#39;node-link&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">json_graph</span><span class="o">.</span><span class="n">node_link_data</span><span class="p">(</span><span class="n">graph_copy</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span> <span class="p">:</span> <span class="n">MSG_GRAPH</span><span class="p">,</span>
                <span class="s1">&#39;name&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                <span class="s1">&#39;uuid&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span>
                <span class="s1">&#39;source_type&#39;</span> <span class="p">:</span> <span class="n">PIPELINE_SOURCE_TYPE</span><span class="p">,</span>
                <span class="s1">&#39;payload&#39;</span> <span class="p">:</span> <span class="n">payload</span><span class="p">,</span>
                <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dashcomm</span><span class="o">.</span><span class="n">write_graph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>

    <span class="c1">############################################################################</span>
    <span class="k">def</span> <span class="nf">__read_msg_from_dash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Receives any messages sent from the dashboards&quot;&quot;&quot;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dashcomm</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">msg</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="c1">############################################################################</span>
    <span class="k">def</span> <span class="nf">__send_status_msg_to_dash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;builds and sends a status message to the dashboards&quot;&quot;&quot;</span>
        <span class="n">payload</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># fetch pertinent metadata from the node</span>
        <span class="n">node_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">node_info</span><span class="p">[</span><span class="s1">&#39;block&#39;</span><span class="p">]</span> <span class="c1"># delete the block from this copy</span>
        <span class="n">payload</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">node_id</span> <span class="p">:</span> <span class="n">node_info</span><span class="p">}</span>

        <span class="c1"># fetch metadata for the incoming edges</span>
        <span class="n">payload</span><span class="p">[</span><span class="s1">&#39;edges&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">node_a</span><span class="p">,</span><span class="n">node_b</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">e_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">in_edges</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="c1"># delete the data object from this copy</span>
            <span class="n">formatted_edge_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__format_edge_data_for_dash_msg</span><span class="p">(</span><span class="n">e_data</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

            <span class="c1"># update the edges dict</span>
            <span class="n">payload</span><span class="p">[</span><span class="s1">&#39;edges&#39;</span><span class="p">][</span><span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">node_a</span><span class="p">,</span><span class="n">node_b</span><span class="p">,</span><span class="n">key</span><span class="p">))]</span> <span class="o">=</span> <span class="n">formatted_edge_data</span>

        <span class="c1"># encode the message as json and send it</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span> <span class="p">:</span> <span class="n">MSG_STATUS</span><span class="p">,</span>
                <span class="s1">&#39;name&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                <span class="s1">&#39;uuid&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span>
                <span class="s1">&#39;source_type&#39;</span> <span class="p">:</span> <span class="n">PIPELINE_SOURCE_TYPE</span><span class="p">,</span>
                <span class="s1">&#39;payload&#39;</span> <span class="p">:</span> <span class="n">payload</span><span class="p">,</span>
                <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dashcomm</span><span class="o">.</span><span class="n">write_status</span><span class="p">(</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="p">)</span>

    <span class="c1">############################################################################</span>
    <span class="k">def</span> <span class="nf">__send_reset_msg_to_dash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;builds and sends a reset message to the dashboards&quot;&quot;&quot;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span> <span class="p">:</span> <span class="n">MSG_RESET</span><span class="p">,</span>
                <span class="s1">&#39;name&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                <span class="s1">&#39;uuid&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span>
                <span class="s1">&#39;source_type&#39;</span> <span class="p">:</span> <span class="n">PIPELINE_SOURCE_TYPE</span><span class="p">,</span>
                <span class="s1">&#39;payload&#39;</span> <span class="p">:</span> <span class="p">{},</span>
                <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dashcomm</span><span class="o">.</span><span class="n">write_reset</span><span class="p">(</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="p">)</span>

    <span class="c1">############################################################################</span>
    <span class="k">def</span> <span class="nf">__send_block_error_msg_to_dash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">error</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;builds and sends an error message to the dashboards&quot;&quot;&quot;</span>
        <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_id</span><span class="p">][</span><span class="s1">&#39;block&#39;</span><span class="p">]</span>

        <span class="n">msg</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span> <span class="p">:</span> <span class="n">MSG_ERROR</span><span class="p">,</span>
                <span class="s1">&#39;name&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                <span class="s1">&#39;uuid&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span>
                <span class="s1">&#39;source_type&#39;</span> <span class="p">:</span> <span class="n">PIPELINE_SOURCE_TYPE</span><span class="p">,</span>
                <span class="s1">&#39;payload&#39;</span> <span class="p">:</span> <span class="p">{</span>
                            <span class="s1">&#39;node_id&#39;</span> <span class="p">:</span> <span class="n">node_id</span><span class="p">,</span>
                            <span class="s1">&#39;block_name&#39;</span> <span class="p">:</span> <span class="n">block</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                            <span class="s1">&#39;block_id&#39;</span>   <span class="p">:</span> <span class="n">block</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                            <span class="s1">&#39;block_uuid&#39;</span> <span class="p">:</span> <span class="n">block</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span>
                            <span class="s1">&#39;error_type&#39;</span> <span class="p">:</span> <span class="n">error</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                            <span class="s1">&#39;error_msg&#39;</span>  <span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">error</span><span class="p">),</span>
                            <span class="p">},</span>
                <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dashcomm</span><span class="o">.</span><span class="n">write_error</span><span class="p">(</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="p">)</span>

    <span class="c1">############################################################################</span>
    <span class="k">def</span> <span class="nf">__send_delete_msg_to_dash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;builds and sends a delete message to the dashboards&quot;&quot;&quot;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span> <span class="p">:</span> <span class="n">MSG_DELETE</span><span class="p">,</span>
                <span class="s1">&#39;name&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                <span class="s1">&#39;uuid&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span>
                <span class="s1">&#39;source_type&#39;</span> <span class="p">:</span> <span class="n">PIPELINE_SOURCE_TYPE</span><span class="p">,</span>
                <span class="s1">&#39;payload&#39;</span> <span class="p">:</span> <span class="p">{},</span>
                <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dashcomm</span><span class="o">.</span><span class="n">write_delete</span><span class="p">(</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="p">)</span>

    <span class="c1">############################################################################</span>
    <span class="k">def</span> <span class="nf">__compute_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">skip_enforcement</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        WARNING:</span>
<span class="sd">            this function should only be called if all incoming edges are</span>
<span class="sd">            populated with data. Ideally it should not be used outside the</span>
<span class="sd">            __compute function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_id</span><span class="p">][</span><span class="s1">&#39;status&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">STATUS_PROCESSING</span>

            <span class="c1"># UPDATE THE DASHBOARD</span>
            <span class="c1"># -----------------------------------</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__read_msg_from_dash</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__send_status_msg_to_dash</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span>

            <span class="c1"># fetch the block for this node</span>
            <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_id</span><span class="p">][</span><span class="s1">&#39;block&#39;</span><span class="p">]</span>

            <span class="c1"># ORGANIZE INPUT DATA FOR COMPUTATION</span>
            <span class="c1"># -----------------------------------</span>
            <span class="c1"># fetch input data for this node</span>
            <span class="n">in_edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">in_edges</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
            <span class="n">arg_data_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;in_index&#39;</span><span class="p">]</span> <span class="p">:</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">in_edges</span><span class="p">}</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">arg_data_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span> <span class="n">arg_data_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="p">)]</span>

            <span class="c1"># assign the task outputs to their appropriate edge</span>
            <span class="n">analytics</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="c1"># COMPUTE DATA IN THE BLOCK</span>
            <span class="c1"># -----------------------------------</span>
            <span class="c1"># (args will be empty for root blocks)</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">_pipeline_process</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span>
                                                    <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
                                                    <span class="n">force_skip</span><span class="o">=</span><span class="n">skip_enforcement</span><span class="p">,</span>
                                                    <span class="n">analytics</span><span class="o">=</span><span class="n">analytics</span><span class="p">)</span>

            <span class="c1"># POPULATE OUTPUT EDGES FOR THIS NODE</span>
            <span class="c1"># -----------------------------------</span>
            <span class="c1"># update the graph with analytics for this block</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">analytics</span><span class="p">)</span>

            <span class="c1"># populate upstream edges with the data we need</span>
            <span class="c1"># get the output edges</span>
            <span class="n">out_edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">out_edges</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
            <span class="c1"># NEED ERROR CHECKING HERE</span>
            <span class="c1"># (psuedo) if n_out == n_expected_out</span>
            <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">void</span><span class="p">:</span>
                <span class="c1"># there&#39;s no output for this block, so we write None to the edges</span>
                <span class="k">for</span> <span class="n">out_edge</span> <span class="ow">in</span> <span class="n">out_edges</span><span class="p">:</span>
                    <span class="n">out_edge</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">out_edge</span> <span class="ow">in</span> <span class="n">out_edges</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span> <span class="n">outputs</span><span class="p">[</span><span class="n">out_edge</span><span class="p">[</span><span class="s1">&#39;out_index&#39;</span><span class="p">]]</span> <span class="p">)</span>
                    <span class="n">out_edge</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
                    <span class="n">out_edge</span><span class="p">[</span><span class="s1">&#39;same_type_for_all_datums&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">is_homogenus_container</span><span class="p">()</span>
                    <span class="n">out_edge</span><span class="p">[</span><span class="s1">&#39;data_stored_in&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">container_type</span>
                    <span class="n">out_edge</span><span class="p">[</span><span class="s1">&#39;n_datums&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">n_datums</span>
                    <span class="n">out_edge</span><span class="p">[</span><span class="s1">&#39;datum_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">datum_type</span>

            <span class="c1"># update node status</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_id</span><span class="p">][</span><span class="s1">&#39;status&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">STATUS_COMPLETE</span>


            <span class="c1"># update the dashboard</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__send_status_msg_to_dash</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__send_block_error_msg_to_dash</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>
            <span class="k">raise</span>

    <span class="c1">############################################################################</span>
    <span class="k">def</span> <span class="nf">__compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">skip_enforcement</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;executes the graph tasks. Relies on Input data being preloaded&quot;&quot;&quot;</span>
        <span class="c1">## NOTE:</span>
        <span class="c1"># add warning that for edges that are non-computable</span>
        <span class="c1">###</span>
        <span class="k">for</span> <span class="n">node_a</span><span class="p">,</span> <span class="n">node_b</span><span class="p">,</span> <span class="n">edge_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">execution_order</span><span class="p">:</span>
            <span class="c1"># check if node_a is a root node (no incoming edges)</span>
            <span class="c1"># these nodes can be computed and the edge populated</span>
            <span class="c1"># immmediately because they have no predecessors</span>
            <span class="c1"># NOTE: this will currently break if a root has more than one</span>
            <span class="c1"># output - JM</span>
            <span class="c1"># ROOT BLOCKS</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">in_degree</span><span class="p">(</span><span class="n">node_a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__compute_block</span><span class="p">(</span><span class="n">node_a</span><span class="p">,</span> <span class="n">skip_enforcement</span><span class="p">)</span>


            <span class="c1"># NON-ROOT BLOCKS</span>
            <span class="c1"># compute this node if all the data is queued</span>
            <span class="n">in_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">in_edges</span><span class="p">(</span><span class="n">node_b</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">data_is_queued</span> <span class="o">=</span> <span class="nb">all</span><span class="p">((</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">in_edges</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">((</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">in_edges</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__compute_block</span><span class="p">(</span><span class="n">node_b</span><span class="p">,</span> <span class="n">skip_enforcement</span><span class="p">)</span>

    <span class="c1">############################################################################</span>
    <span class="c1">#                               util</span>
    <span class="c1">############################################################################</span>
<div class="viewcode-block" id="Pipeline.get_tasks"><a class="viewcode-back" href="../../../api/imagepypelines.Pipeline.html#imagepypelines.Pipeline.get_tasks">[docs]</a>    <span class="k">def</span> <span class="nf">get_tasks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;generates a dictionary task represenation of the pipeline, which can</span>
<span class="sd">        be used to make other pipelines.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">static</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">attrs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">arg_vars</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;args&#39;</span><span class="p">])</span>
            <span class="n">out_vars</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;outputs&#39;</span><span class="p">])</span>
            <span class="n">block</span> <span class="o">=</span> <span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;block&#39;</span><span class="p">]</span>

            <span class="c1"># ignore leaf blocks</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">Leaf</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">static</span><span class="p">[</span><span class="n">out_vars</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span><span class="p">,)</span> <span class="o">+</span> <span class="n">arg_vars</span>

        <span class="k">return</span> <span class="n">static</span></div>

    <span class="c1">############################################################################</span>
<div class="viewcode-block" id="Pipeline.get_predecessors"><a class="viewcode-back" href="../../../api/imagepypelines.Pipeline.html#imagepypelines.Pipeline.get_predecessors">[docs]</a>    <span class="k">def</span> <span class="nf">get_predecessors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;fetches the names of the variables which must be computed/loaded</span>
<span class="sd">        before the given variable can be computed.</span>

<span class="sd">        Args:</span>
<span class="sd">            var(str): name of variable to find predecessors for</span>

<span class="sd">        Returns:</span>
<span class="sd">            set: an unordered set of the variables that must be computed before</span>
<span class="sd">                the given variable can be calculated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE: we could possibly speed this function up by using a depth</span>
        <span class="c1"># finding algorithm instead?</span>
        <span class="c1"># define a recursive function to get edges from all predecessor nodes</span>
        <span class="n">preds</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">nodes_checked</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">def</span> <span class="nf">_get_priors</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">node_a</span><span class="p">,</span><span class="n">node_b</span><span class="p">,</span><span class="n">var_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">in_edges</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="s1">&#39;var_name&#39;</span><span class="p">):</span>
                <span class="n">preds</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">var_name</span><span class="p">)</span>
                <span class="c1"># recursively add edges from the source node</span>
                <span class="k">if</span> <span class="n">node_a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nodes_checked</span><span class="p">:</span>
                    <span class="n">_get_priors</span><span class="p">(</span><span class="n">node_a</span><span class="p">)</span>

            <span class="n">nodes_checked</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="n">_get_priors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="s1">&#39;block_node_id&#39;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">preds</span></div>

    <span class="c1">############################################################################</span>
<div class="viewcode-block" id="Pipeline.get_successors"><a class="viewcode-back" href="../../../api/imagepypelines.Pipeline.html#imagepypelines.Pipeline.get_successors">[docs]</a>    <span class="k">def</span> <span class="nf">get_successors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;fetches the names of the variables which depend on this variable</span>
<span class="sd">        before they can be computed</span>

<span class="sd">        Args:</span>
<span class="sd">            var(str): name of variable to find successors for</span>

<span class="sd">        Returns:</span>
<span class="sd">            set: an unordered set of the variables that can only be computed</span>
<span class="sd">                once the given variable has been</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE: we could possibly speed this function up by using a depth</span>
        <span class="c1"># finding algorithm instead?</span>
        <span class="c1"># define a recursive function to get edges from all successor nodes</span>
        <span class="n">succs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">nodes_checked</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">def</span> <span class="nf">_get_latters</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">node_a</span><span class="p">,</span><span class="n">node_b</span><span class="p">,</span><span class="n">var_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">out_edges</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="s1">&#39;var_name&#39;</span><span class="p">):</span>
                <span class="n">succs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">var_name</span><span class="p">)</span>
                <span class="c1"># recursively add edges from the source node</span>
                <span class="k">if</span> <span class="n">node_b</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nodes_checked</span><span class="p">:</span>
                    <span class="n">_get_latters</span><span class="p">(</span><span class="n">node_b</span><span class="p">)</span>

            <span class="n">nodes_checked</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># start with every node node after this one - (so we don&#39;t include companion outputs)</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">next_node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">out_edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="s1">&#39;block_node_id&#39;</span><span class="p">]):</span>
            <span class="n">_get_latters</span><span class="p">(</span><span class="n">next_node</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">succs</span></div>

    <span class="c1">############################################################################</span>
<div class="viewcode-block" id="Pipeline.get_types_for"><a class="viewcode-back" href="../../../api/imagepypelines.Pipeline.html#imagepypelines.Pipeline.get_types_for">[docs]</a>    <span class="k">def</span> <span class="nf">get_types_for</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;fetches the enforced types for this variable of the pipeline.</span>

<span class="sd">        More specifically, these are the types that won&#39;t throw an error</span>
<span class="sd">        within the block</span>

<span class="sd">        Args:</span>
<span class="sd">            var(str): the name of the variable</span>

<span class="sd">        Returns:</span>
<span class="sd">            (:obj:`tuple` of :obj:`type`): the types enforced for</span>
<span class="sd">        the given variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># INTERNAL HELPER FUNCTION</span>
        <span class="k">def</span> <span class="nf">_dominant_type</span><span class="p">(</span><span class="n">types1</span><span class="p">,</span> <span class="n">types2</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;determines which set of types are dominant between two tuples of</span>
<span class="sd">            types</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># make types a tuple if they aren&#39;t already to simply the code</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">types1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">types1</span><span class="p">,(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">,</span><span class="nb">set</span><span class="p">)):</span>
                <span class="n">types1</span> <span class="o">=</span> <span class="p">(</span><span class="n">types1</span><span class="p">,)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">types2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">types2</span><span class="p">,(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">,</span><span class="nb">set</span><span class="p">)):</span>
                <span class="n">types2</span> <span class="o">=</span> <span class="p">(</span><span class="n">types2</span><span class="p">,)</span>

            <span class="c1"># if either type is None, then the other automatically supercedes</span>
            <span class="k">if</span> <span class="n">types1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">types2</span>
            <span class="k">elif</span> <span class="n">types2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">types1</span>
            <span class="c1"># both must lists/tuples of types - we want the intersection</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">okay_types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">types1</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span> <span class="nb">set</span><span class="p">(</span><span class="n">types2</span><span class="p">)</span> <span class="p">)</span>
                <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span> <span class="n">okay_types</span> <span class="p">)</span>
        <span class="c1"># END INTERNAL HELPER FUNC</span>

        <span class="c1"># Iterate through pipeline args and compute the dominant type</span>
        <span class="n">dom_types</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># fetch the node that produced the variable</span>
        <span class="n">source_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="s1">&#39;block_node_id&#39;</span><span class="p">]</span>
        <span class="c1"># iterate through all nodes it&#39;s connected to and fetch their types</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">node_b</span><span class="p">,</span><span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">out_edges</span><span class="p">(</span><span class="n">source_node</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="c1"># only if this out edge is for the given var</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="s1">&#39;var_name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">var</span><span class="p">):</span>
                <span class="c1"># fetch target block object</span>
                <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_b</span><span class="p">][</span><span class="s1">&#39;block&#39;</span><span class="p">]</span>
                <span class="c1"># fetch the actual name of the argument in the target&#39;s process function</span>
                <span class="n">target_arg</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">args</span><span class="p">[</span> <span class="n">edge</span><span class="p">[</span><span class="s1">&#39;in_index&#39;</span><span class="p">]</span> <span class="p">]</span>
                <span class="c1"># skip updating this target if its enforcement is disabled</span>
                <span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">skip_enforcement</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># compute and update the dominant type</span>
                <span class="n">dom_types</span> <span class="o">=</span> <span class="n">_dominant_type</span><span class="p">(</span>
                                            <span class="n">target</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">target_arg</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                            <span class="n">dom_types</span>
                                            <span class="p">)</span>

        <span class="k">return</span> <span class="n">dom_types</span></div>

    <span class="c1">############################################################################</span>
<div class="viewcode-block" id="Pipeline.get_shapes_for"><a class="viewcode-back" href="../../../api/imagepypelines.Pipeline.html#imagepypelines.Pipeline.get_shapes_for">[docs]</a>    <span class="k">def</span> <span class="nf">get_shapes_for</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;fetches the enforced shapes for the given variable</span>

<span class="sd">        More specifically, these are the shapes that won&#39;t throw an</span>
<span class="sd">        error within the block</span>

<span class="sd">        Args:</span>
<span class="sd">            var(str): the name of the variable</span>

<span class="sd">        Returns:</span>
<span class="sd">            (:obj:`tuple` of :obj:`tuple`): the shapes enforced for</span>
<span class="sd">        the given variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># INTERNAL HELPER FUNCTION</span>
        <span class="k">def</span> <span class="nf">_dominant_shape</span><span class="p">(</span><span class="n">shape1</span><span class="p">,</span> <span class="n">shape2</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;determines which shape is dominant between shapes, or calculates</span>
<span class="sd">            the new compatible shape if it&#39;s required.&quot;&quot;&quot;</span>
            <span class="c1"># if either shape is None, then the other automatically supercedes</span>
            <span class="k">if</span> <span class="n">shape1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">shape2</span>
            <span class="k">elif</span> <span class="n">shape2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">shape1</span>
            <span class="c1"># both must lists or tuples</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># if the ndim aren&#39;t the same, then there is no compatible shape</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape2</span><span class="p">):</span>
                    <span class="k">return</span> <span class="nb">tuple</span><span class="p">()</span>

                <span class="n">new_shape</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="c1"># other we have to iterate through and find the dominant axes</span>
                <span class="k">for</span> <span class="n">ax1</span><span class="p">,</span><span class="n">ax2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">shape1</span><span class="p">,</span><span class="n">shape2</span><span class="p">):</span>
                    <span class="c1"># if one axis is None, then the other is dominant</span>
                    <span class="k">if</span> <span class="n">ax1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">new_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax2</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">ax2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">new_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax1</span><span class="p">)</span>
                    <span class="c1"># both must be integers</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">ax1</span> <span class="o">==</span> <span class="n">ax2</span><span class="p">:</span>
                            <span class="c1"># if both axial lengths are identical, then we</span>
                            <span class="c1"># can append either to the new shape</span>
                            <span class="n">new_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax1</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># if the axial lengths aren&#39;t identical, there is</span>
                            <span class="c1"># no compatible axis and thus no compatible shape</span>
                            <span class="c1"># so we return an empty shape</span>
                            <span class="k">return</span> <span class="nb">tuple</span><span class="p">()</span>

                <span class="k">return</span> <span class="n">new_shape</span>
        <span class="c1"># END INTERNAL HELPER FUNC</span>

        <span class="n">dom_shapes</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span>
        <span class="c1"># fetch the node that produced the variable</span>
        <span class="n">source_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="s1">&#39;block_node_id&#39;</span><span class="p">]</span>
        <span class="c1"># iterate through all nodes it&#39;s connected to and fetch their types</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">node_b</span><span class="p">,</span><span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">out_edges</span><span class="p">(</span><span class="n">source_node</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="c1"># only if this out edge is for the given var</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="s1">&#39;var_name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">var</span><span class="p">):</span>
                <span class="c1"># fetch target block object</span>
                <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_b</span><span class="p">][</span><span class="s1">&#39;block&#39;</span><span class="p">]</span>
                <span class="c1"># fetch the actual name of the argument in the target&#39;s process function</span>
                <span class="n">target_arg</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">args</span><span class="p">[</span> <span class="n">edge</span><span class="p">[</span><span class="s1">&#39;in_index&#39;</span><span class="p">]</span> <span class="p">]</span>
                <span class="c1"># skip updating this target if its enforcement is disabled</span>
                <span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">skip_enforcement</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="c1"># fetch target shapes</span>
                <span class="n">target_shapes</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">shapes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">target_arg</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="c1"># make target shapes an 1 elem iterable if it&#39;s None</span>
                <span class="n">target_shapes</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="k">if</span> <span class="n">target_shapes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">target_shapes</span>
                <span class="c1"># calculate all possible shape permutations</span>
                <span class="n">all_possible</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span>
                                                <span class="nb">set</span><span class="p">(</span><span class="n">target_shapes</span><span class="p">),</span>
                                                <span class="nb">set</span><span class="p">(</span><span class="n">dom_shapes</span><span class="p">)</span>
                                                <span class="p">)</span>

                <span class="c1"># check every possible combination</span>
                <span class="n">all_workable</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">shape1</span><span class="p">,</span><span class="n">shape2</span> <span class="ow">in</span> <span class="n">all_possible</span><span class="p">:</span>
                    <span class="n">all_workable</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">_dominant_shape</span><span class="p">(</span><span class="n">shape1</span><span class="p">,</span> <span class="n">shape2</span><span class="p">)</span> <span class="p">)</span>

                <span class="c1"># remove empty tuples (i.e. incompatible shapes)</span>
                <span class="n">dom_shapes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">all_workable</span> <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="nb">tuple</span><span class="p">())</span>
                <span class="c1">#update the dominant type</span>

            <span class="k">return</span> <span class="n">dom_shapes</span></div>

    <span class="c1">############################################################################</span>
<div class="viewcode-block" id="Pipeline.get_containers_for"><a class="viewcode-back" href="../../../api/imagepypelines.Pipeline.html#imagepypelines.Pipeline.get_containers_for">[docs]</a>    <span class="k">def</span> <span class="nf">get_containers_for</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;fetches the enforced containers for this variable of the pipeline.</span>

<span class="sd">        More specifically, these are the containers that won&#39;t throw an error</span>
<span class="sd">        within the block</span>

<span class="sd">        Args:</span>
<span class="sd">            var(str): the name of the variable</span>

<span class="sd">        Returns:</span>
<span class="sd">            (:obj:`tuple` of :obj:`type`): the containers enforced for</span>
<span class="sd">        the given variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># INTERNAL HELPER FUNCTION</span>
        <span class="k">def</span> <span class="nf">_dominant_container</span><span class="p">(</span><span class="n">containers1</span><span class="p">,</span> <span class="n">containers2</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;determines which set of containers are dominant between two tuples of</span>
<span class="sd">            containers</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># make containers a tuple if they aren&#39;t already to simply the code</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">containers1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">containers1</span><span class="p">,(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">,</span><span class="nb">set</span><span class="p">)):</span>
                <span class="n">containers1</span> <span class="o">=</span> <span class="p">(</span><span class="n">containers1</span><span class="p">,)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">containers2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">containers2</span><span class="p">,(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">,</span><span class="nb">set</span><span class="p">)):</span>
                <span class="n">containers2</span> <span class="o">=</span> <span class="p">(</span><span class="n">containers2</span><span class="p">,)</span>

            <span class="c1"># if either container is None, then the other automatically supercedes</span>
            <span class="k">if</span> <span class="n">containers1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">containers2</span>
            <span class="k">elif</span> <span class="n">containers2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">containers1</span>
            <span class="c1"># both must lists/tuples of containers - we want the intersection</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">okay_containers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">containers1</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span> <span class="nb">set</span><span class="p">(</span><span class="n">containers2</span><span class="p">)</span> <span class="p">)</span>
                <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span> <span class="n">okay_containers</span> <span class="p">)</span>
        <span class="c1"># END INTERNAL HELPER FUNC</span>

        <span class="c1"># Iterate through pipeline args and compute the dominant container</span>
        <span class="n">dom_containers</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># fetch the node that produced the variable</span>
        <span class="n">source_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="s1">&#39;block_node_id&#39;</span><span class="p">]</span>
        <span class="c1"># iterate through all nodes it&#39;s connected to and fetch their containers</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">node_b</span><span class="p">,</span><span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">out_edges</span><span class="p">(</span><span class="n">source_node</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="c1"># only if this out edge is for the given var</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="s1">&#39;var_name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">var</span><span class="p">):</span>
                <span class="c1"># fetch target block object</span>
                <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_b</span><span class="p">][</span><span class="s1">&#39;block&#39;</span><span class="p">]</span>
                <span class="c1"># fetch the actual name of the argument in the target&#39;s process function</span>
                <span class="n">target_arg</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">args</span><span class="p">[</span> <span class="n">edge</span><span class="p">[</span><span class="s1">&#39;in_index&#39;</span><span class="p">]</span> <span class="p">]</span>
                <span class="c1"># skip updating this target if its enforcement is disabled</span>
                <span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">skip_enforcement</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># compute and update the dominant container</span>
                <span class="n">dom_containers</span> <span class="o">=</span> <span class="n">_dominant_container</span><span class="p">(</span>
                                            <span class="n">target</span><span class="o">.</span><span class="n">containers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">target_arg</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                            <span class="n">dom_containers</span>
                                            <span class="p">)</span>

        <span class="k">return</span> <span class="n">dom_containers</span></div>

    <span class="c1">############################################################################</span>
<div class="viewcode-block" id="Pipeline.assign_input_index"><a class="viewcode-back" href="../../../api/imagepypelines.Pipeline.html#imagepypelines.Pipeline.assign_input_index">[docs]</a>    <span class="k">def</span> <span class="nf">assign_input_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;reassigns the index for this variable in the process argument list&quot;&quot;&quot;</span>
        <span class="c1"># reset the input index to a new one</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></div>

    <span class="c1">############################################################################</span>
<div class="viewcode-block" id="Pipeline.debug_serialization"><a class="viewcode-back" href="../../../api/imagepypelines.Pipeline.html#imagepypelines.Pipeline.debug_serialization">[docs]</a>    <span class="k">def</span> <span class="nf">debug_serialization</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;helper function to debug what part of a block is not serializable&quot;&quot;&quot;</span>
        <span class="c1"># NOTE: needs to be updated to use dill&#39;s builtin debugging tools</span>
        <span class="n">error</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># fetch the static graph represenation</span>
        <span class="n">static</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_tasks</span><span class="p">()</span>

        <span class="c1"># iterate through all tasks and check if their components are serializable</span>
        <span class="n">raise_error</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">static</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">block</span> <span class="o">=</span> <span class="n">task</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># iterate through every value in the block&#39;s __dict__</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">val</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">dill</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;error serializing </span><span class="si">{}</span><span class="s2">.</span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">block</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">e</span><span class="p">))</span>
                    <span class="n">error</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">error</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;no pickling issues detected&quot;</span><span class="p">)</span></div>

    <span class="c1">############################################################################</span>
<div class="viewcode-block" id="Pipeline.rename"><a class="viewcode-back" href="../../../api/imagepypelines.Pipeline.html#imagepypelines.Pipeline.rename">[docs]</a>    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;renames the Pipeline to the given name. The id is reset in this process&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">PipelineError</span><span class="p">(</span><span class="s2">&quot;name must be string&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;being renamed from &#39;</span><span class="si">%s</span><span class="s2">&#39; to &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
        <span class="n">old_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="c1"># reset the logger with the new id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">get_logger</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">pipeline</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># log the new name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;renamed from &#39;</span><span class="si">%s</span><span class="s2">&#39; to &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">old_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span></div>


    <span class="c1">############################################################################</span>
    <span class="c1">#                               magic</span>
    <span class="c1">############################################################################</span>
<div class="viewcode-block" id="Pipeline.__call__"><a class="viewcode-back" href="../../../api/imagepypelines.Pipeline.html#imagepypelines.Pipeline.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">pos_data</span><span class="p">,</span> <span class="n">fetch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skip_enforcement</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwdata</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;aliases self.process with same signature for more natural use&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="o">*</span><span class="n">pos_data</span><span class="p">,</span> <span class="n">fetch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skip_enforcement</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                   <span class="o">**</span><span class="n">kwdata</span><span class="p">)</span></div>

    <span class="c1">############################################################################</span>
    <span class="c1"># COPYING &amp; PICKLING</span>
    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span>

    <span class="c1">############################################################################</span>
    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;resets the uuid in the event of a copy&quot;&quot;&quot;</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">uuid4</span><span class="p">()</span><span class="o">.</span><span class="n">hex</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="c1"># updates the logger for the new state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">get_logger</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">pipeline</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1">############################################################################</span>
    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;deletes pipeline and sends a delete message to the dashboard&quot;&quot;&quot;</span>
        <span class="c1"># self.__send_delete_msg_to_dash()</span>

    <span class="c1">############################################################################</span>
    <span class="c1">#                               properties</span>
    <span class="c1">############################################################################</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;str: an unique id for this pipeline</span>

<span class="sd">        This id is a combination of the pipeline&#39;s non-unique name and</span>
<span class="sd">        part of it&#39;s uuid (last 6 characters by default).</span>
<span class="sd">        The entropy of this id can be increased by increasing ImagePypelines</span>
<span class="sd">        UUID_ORDER variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">#</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">uuid</span><span class="p">[</span><span class="o">-</span><span class="n">UUID_ORDER</span><span class="p">:])</span>

    <span class="c1">############################################################################</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">execution_order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:obj:`Generator`: topologically sorted edges of the pipeline&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">topological_sort</span><span class="p">(</span> <span class="n">nx</span><span class="o">.</span><span class="n">line_graph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span> <span class="p">)</span>

    <span class="c1">############################################################################</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:obj:`list` of :obj:`str`: arguments in the order they are expected&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexed_inputs</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyword_inputs</span>

    <span class="c1">############################################################################</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;int: number of arguments for the process function&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>

    <span class="c1">############################################################################</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:obj:`set` of :obj:`Block`: unordered set of pipeline blocks&quot;&quot;&quot;</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s1">&#39;block&#39;</span><span class="p">):</span>
            <span class="c1"># ignore leaves</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">Leaf</span><span class="p">):</span>
                <span class="n">blocks</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">blocks</span>

    <span class="c1">############################################################################</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:obj:`list` of :obj:`str`: all variables in the pipeline&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="p">)</span>

    <span class="c1">############################################################################</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;(obj:`dict` of str : type): the types compatible for input arguments.</span>
<span class="sd">        This is computed dynamically so it will automatically reflect changes to</span>
<span class="sd">        Blocks&quot;&quot;&quot;</span>
        <span class="c1"># Iterate through pipeline args and compute the dominant type</span>
        <span class="n">types</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">pype_arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="n">arg_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_types_for</span><span class="p">(</span><span class="n">pype_arg</span><span class="p">)</span>
            <span class="n">types</span><span class="p">[</span><span class="n">pype_arg</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg_types</span>
            <span class="c1"># check if there is at least 1 valid type</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">arg_types</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg_types</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># log it, but don&#39;t throw an error</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;no valid types found for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pype_arg</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">types</span>

    <span class="c1">############################################################################</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shapes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;(obj:`dict` of str : tuple): the shapes compatible for input</span>
<span class="sd">        arguments. This is computed dynamically so it will automatically reflect</span>
<span class="sd">        changes to Blocks&quot;&quot;&quot;</span>
        <span class="c1"># Iterate through pipeline args and compute the dominant shapes</span>
        <span class="n">shapes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">pype_arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="n">arg_shapes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shapes_for</span><span class="p">(</span><span class="n">pype_arg</span><span class="p">)</span>
            <span class="n">shapes</span><span class="p">[</span><span class="n">pype_arg</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg_shapes</span>
            <span class="c1"># check if there is at least 1 valid type</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">arg_shapes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg_shapes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># log it, but don&#39;t throw an error</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;no valid shapes found for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pype_arg</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">shapes</span>

    <span class="c1">############################################################################</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">containers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;(obj:`dict` of str : container): the containers compatible for input</span>
<span class="sd">        arguments. This is computed dynamically so it will automatically reflect</span>
<span class="sd">        changes to Blocks&quot;&quot;&quot;</span>
        <span class="c1"># Iterate through pipeline args and compute the dominant container</span>
        <span class="n">containers</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">pype_arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="n">arg_containers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_containers_for</span><span class="p">(</span><span class="n">pype_arg</span><span class="p">)</span>
            <span class="n">containers</span><span class="p">[</span><span class="n">pype_arg</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg_containers</span>
            <span class="c1"># check if there is at least 1 valid container</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">arg_containers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg_containers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># log it, but don&#39;t throw an error</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;no valid containers found for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pype_arg</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">containers</span>

    <span class="c1">############################################################################</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">void_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;set: unordered set of variables which won&#39;t have data assigned to them</span>
<span class="sd">            during runtime&quot;&quot;&quot;</span>
        <span class="n">void_vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span><span class="p">,</span><span class="n">attrs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="c1"># if the block is void (has no outputs), then we add the variable names to a set</span>
            <span class="k">if</span> <span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;block&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">void</span><span class="p">:</span>
                <span class="n">void_vars</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;outputs&#39;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">void_vars</span>

    <span class="c1">############################################################################</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">noncomputable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;set: unordered set of every variable that can&#39;t be computed because</span>
<span class="sd">            it relies on void data&quot;&quot;&quot;</span>
        <span class="n">noncomputable</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">void_vars</span><span class="p">:</span>
            <span class="n">noncomputable</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_successors</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">noncomputable</span></div>
</pre></div>
<div class="section">
   
</div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright  2018-2020 Jeff Maggio, Ryan Hartzell, Jai Mehra, and collaborators.<br/>
      Last updated on Nov 10, 2020.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.4.4.<br/>
    </p>
  </div>
</footer>
  </body>
</html>